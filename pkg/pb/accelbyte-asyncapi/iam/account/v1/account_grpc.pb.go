// Copyright (c) 2025 AccelByte Inc. All Rights Reserved.
// This is licensed software from AccelByte Inc, for limitations
// and restrictions contact your company contract manager.

// source: IAM/AsyncAPI/account.yaml (0.1.0)

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.9
// source: accelbyte-asyncapi/iam/account/v1/account.proto

package account

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserAccountUserAccountCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountCreatedService/OnMessage"
)

// UserAccountUserAccountCreatedServiceClient is the client API for UserAccountUserAccountCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountCreated to the User Account channel. (oneOf variant) (userAccount UserAccountCreated)
type UserAccountUserAccountCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountCreatedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountCreatedServiceClient {
	return &userAccountUserAccountCreatedServiceClient{cc}
}

func (c *userAccountUserAccountCreatedServiceClient) OnMessage(ctx context.Context, in *UserAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountCreatedServiceServer is the server API for UserAccountUserAccountCreatedService service.
// All implementations should embed UnimplementedUserAccountUserAccountCreatedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountCreated to the User Account channel. (oneOf variant) (userAccount UserAccountCreated)
type UserAccountUserAccountCreatedServiceServer interface {
	OnMessage(context.Context, *UserAccountCreated) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountCreatedServiceServer struct{}

func (UnimplementedUserAccountUserAccountCreatedServiceServer) OnMessage(context.Context, *UserAccountCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountCreatedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountCreatedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountCreatedServiceServer()
}

func RegisterUserAccountUserAccountCreatedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountCreatedService_ServiceDesc, srv)
}

func _UserAccountUserAccountCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountCreatedServiceServer).OnMessage(ctx, req.(*UserAccountCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountCreatedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountCreatedService",
	HandlerType: (*UserAccountUserAccountCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountDeletedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountDeletedService/OnMessage"
)

// UserAccountUserAccountDeletedServiceClient is the client API for UserAccountUserAccountDeletedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountDeleted to the User Account channel. (oneOf variant) (userAccount UserAccountDeleted)
type UserAccountUserAccountDeletedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountDeletedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountDeletedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountDeletedServiceClient {
	return &userAccountUserAccountDeletedServiceClient{cc}
}

func (c *userAccountUserAccountDeletedServiceClient) OnMessage(ctx context.Context, in *UserAccountDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountDeletedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountDeletedServiceServer is the server API for UserAccountUserAccountDeletedService service.
// All implementations should embed UnimplementedUserAccountUserAccountDeletedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountDeleted to the User Account channel. (oneOf variant) (userAccount UserAccountDeleted)
type UserAccountUserAccountDeletedServiceServer interface {
	OnMessage(context.Context, *UserAccountDeleted) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountDeletedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountDeletedServiceServer struct{}

func (UnimplementedUserAccountUserAccountDeletedServiceServer) OnMessage(context.Context, *UserAccountDeleted) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountDeletedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountDeletedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountDeletedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountDeletedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountDeletedServiceServer()
}

func RegisterUserAccountUserAccountDeletedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountDeletedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountDeletedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountDeletedService_ServiceDesc, srv)
}

func _UserAccountUserAccountDeletedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountDeletedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountDeletedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountDeletedServiceServer).OnMessage(ctx, req.(*UserAccountDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountDeletedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountDeletedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountDeletedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountDeletedService",
	HandlerType: (*UserAccountUserAccountDeletedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountDeletedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountEnabledService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountEnabledService/OnMessage"
)

// UserAccountUserAccountEnabledServiceClient is the client API for UserAccountUserAccountEnabledService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountEnabled to the User Account channel. (oneOf variant) (userAccount UserAccountEnabled)
type UserAccountUserAccountEnabledServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountEnabled, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountEnabledServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountEnabledServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountEnabledServiceClient {
	return &userAccountUserAccountEnabledServiceClient{cc}
}

func (c *userAccountUserAccountEnabledServiceClient) OnMessage(ctx context.Context, in *UserAccountEnabled, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountEnabledService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountEnabledServiceServer is the server API for UserAccountUserAccountEnabledService service.
// All implementations should embed UnimplementedUserAccountUserAccountEnabledServiceServer
// for forward compatibility.
//
// Publishes a UserAccountEnabled to the User Account channel. (oneOf variant) (userAccount UserAccountEnabled)
type UserAccountUserAccountEnabledServiceServer interface {
	OnMessage(context.Context, *UserAccountEnabled) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountEnabledServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountEnabledServiceServer struct{}

func (UnimplementedUserAccountUserAccountEnabledServiceServer) OnMessage(context.Context, *UserAccountEnabled) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountEnabledServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountEnabledServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountEnabledServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountEnabledServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountEnabledServiceServer()
}

func RegisterUserAccountUserAccountEnabledServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountEnabledServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountEnabledServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountEnabledService_ServiceDesc, srv)
}

func _UserAccountUserAccountEnabledService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountEnabled)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountEnabledServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountEnabledService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountEnabledServiceServer).OnMessage(ctx, req.(*UserAccountEnabled))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountEnabledService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountEnabledService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountEnabledService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountEnabledService",
	HandlerType: (*UserAccountUserAccountEnabledServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountEnabledService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountDisabledService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountDisabledService/OnMessage"
)

// UserAccountUserAccountDisabledServiceClient is the client API for UserAccountUserAccountDisabledService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountDisabled to the User Account channel. (oneOf variant) (userAccount UserAccountDisabled)
type UserAccountUserAccountDisabledServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountDisabled, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountDisabledServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountDisabledServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountDisabledServiceClient {
	return &userAccountUserAccountDisabledServiceClient{cc}
}

func (c *userAccountUserAccountDisabledServiceClient) OnMessage(ctx context.Context, in *UserAccountDisabled, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountDisabledService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountDisabledServiceServer is the server API for UserAccountUserAccountDisabledService service.
// All implementations should embed UnimplementedUserAccountUserAccountDisabledServiceServer
// for forward compatibility.
//
// Publishes a UserAccountDisabled to the User Account channel. (oneOf variant) (userAccount UserAccountDisabled)
type UserAccountUserAccountDisabledServiceServer interface {
	OnMessage(context.Context, *UserAccountDisabled) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountDisabledServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountDisabledServiceServer struct{}

func (UnimplementedUserAccountUserAccountDisabledServiceServer) OnMessage(context.Context, *UserAccountDisabled) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountDisabledServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountDisabledServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountDisabledServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountDisabledServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountDisabledServiceServer()
}

func RegisterUserAccountUserAccountDisabledServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountDisabledServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountDisabledServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountDisabledService_ServiceDesc, srv)
}

func _UserAccountUserAccountDisabledService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountDisabled)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountDisabledServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountDisabledService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountDisabledServiceServer).OnMessage(ctx, req.(*UserAccountDisabled))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountDisabledService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountDisabledService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountDisabledService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountDisabledService",
	HandlerType: (*UserAccountUserAccountDisabledServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountDisabledService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountEmailUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountEmailUpdatedService/OnMessage"
)

// UserAccountUserAccountEmailUpdatedServiceClient is the client API for UserAccountUserAccountEmailUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountEmailUpdated to the User Account channel. (oneOf variant) (userAccount UserAccountEmailUpdated)
type UserAccountUserAccountEmailUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountEmailUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountEmailUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountEmailUpdatedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountEmailUpdatedServiceClient {
	return &userAccountUserAccountEmailUpdatedServiceClient{cc}
}

func (c *userAccountUserAccountEmailUpdatedServiceClient) OnMessage(ctx context.Context, in *UserAccountEmailUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountEmailUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountEmailUpdatedServiceServer is the server API for UserAccountUserAccountEmailUpdatedService service.
// All implementations should embed UnimplementedUserAccountUserAccountEmailUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountEmailUpdated to the User Account channel. (oneOf variant) (userAccount UserAccountEmailUpdated)
type UserAccountUserAccountEmailUpdatedServiceServer interface {
	OnMessage(context.Context, *UserAccountEmailUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountEmailUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountEmailUpdatedServiceServer struct{}

func (UnimplementedUserAccountUserAccountEmailUpdatedServiceServer) OnMessage(context.Context, *UserAccountEmailUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountEmailUpdatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountEmailUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountEmailUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountEmailUpdatedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountEmailUpdatedServiceServer()
}

func RegisterUserAccountUserAccountEmailUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountEmailUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountEmailUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountEmailUpdatedService_ServiceDesc, srv)
}

func _UserAccountUserAccountEmailUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountEmailUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountEmailUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountEmailUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountEmailUpdatedServiceServer).OnMessage(ctx, req.(*UserAccountEmailUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountEmailUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountEmailUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountEmailUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountEmailUpdatedService",
	HandlerType: (*UserAccountUserAccountEmailUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountEmailUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountPasswordUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountPasswordUpdatedService/OnMessage"
)

// UserAccountUserAccountPasswordUpdatedServiceClient is the client API for UserAccountUserAccountPasswordUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountPasswordUpdated to the User Account channel. (oneOf variant) (userAccount UserAccountPasswordUpdated)
type UserAccountUserAccountPasswordUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountPasswordUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountPasswordUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountPasswordUpdatedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountPasswordUpdatedServiceClient {
	return &userAccountUserAccountPasswordUpdatedServiceClient{cc}
}

func (c *userAccountUserAccountPasswordUpdatedServiceClient) OnMessage(ctx context.Context, in *UserAccountPasswordUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountPasswordUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountPasswordUpdatedServiceServer is the server API for UserAccountUserAccountPasswordUpdatedService service.
// All implementations should embed UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountPasswordUpdated to the User Account channel. (oneOf variant) (userAccount UserAccountPasswordUpdated)
type UserAccountUserAccountPasswordUpdatedServiceServer interface {
	OnMessage(context.Context, *UserAccountPasswordUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer struct{}

func (UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer) OnMessage(context.Context, *UserAccountPasswordUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountPasswordUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountPasswordUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountPasswordUpdatedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountPasswordUpdatedServiceServer()
}

func RegisterUserAccountUserAccountPasswordUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountPasswordUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountPasswordUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountPasswordUpdatedService_ServiceDesc, srv)
}

func _UserAccountUserAccountPasswordUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountPasswordUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountPasswordUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountPasswordUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountPasswordUpdatedServiceServer).OnMessage(ctx, req.(*UserAccountPasswordUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountPasswordUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountPasswordUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountPasswordUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountPasswordUpdatedService",
	HandlerType: (*UserAccountUserAccountPasswordUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountPasswordUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountBannedService/OnMessage"
)

// UserAccountUserAccountBannedServiceClient is the client API for UserAccountUserAccountBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountBanned to the User Account channel. (oneOf variant) (userAccount UserAccountBanned)
type UserAccountUserAccountBannedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountBannedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountBannedServiceClient {
	return &userAccountUserAccountBannedServiceClient{cc}
}

func (c *userAccountUserAccountBannedServiceClient) OnMessage(ctx context.Context, in *UserAccountBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountBannedServiceServer is the server API for UserAccountUserAccountBannedService service.
// All implementations should embed UnimplementedUserAccountUserAccountBannedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountBanned to the User Account channel. (oneOf variant) (userAccount UserAccountBanned)
type UserAccountUserAccountBannedServiceServer interface {
	OnMessage(context.Context, *UserAccountBanned) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountBannedServiceServer struct{}

func (UnimplementedUserAccountUserAccountBannedServiceServer) OnMessage(context.Context, *UserAccountBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountBannedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountBannedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountBannedServiceServer()
}

func RegisterUserAccountUserAccountBannedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountBannedService_ServiceDesc, srv)
}

func _UserAccountUserAccountBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountBannedServiceServer).OnMessage(ctx, req.(*UserAccountBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountBannedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountBannedService",
	HandlerType: (*UserAccountUserAccountBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountUnbannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountUnbannedService/OnMessage"
)

// UserAccountUserAccountUnbannedServiceClient is the client API for UserAccountUserAccountUnbannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountUnbanned to the User Account channel. (oneOf variant) (userAccount UserAccountUnbanned)
type UserAccountUserAccountUnbannedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountUnbanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountUnbannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountUnbannedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountUnbannedServiceClient {
	return &userAccountUserAccountUnbannedServiceClient{cc}
}

func (c *userAccountUserAccountUnbannedServiceClient) OnMessage(ctx context.Context, in *UserAccountUnbanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountUnbannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountUnbannedServiceServer is the server API for UserAccountUserAccountUnbannedService service.
// All implementations should embed UnimplementedUserAccountUserAccountUnbannedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountUnbanned to the User Account channel. (oneOf variant) (userAccount UserAccountUnbanned)
type UserAccountUserAccountUnbannedServiceServer interface {
	OnMessage(context.Context, *UserAccountUnbanned) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountUnbannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountUnbannedServiceServer struct{}

func (UnimplementedUserAccountUserAccountUnbannedServiceServer) OnMessage(context.Context, *UserAccountUnbanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountUnbannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountUnbannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountUnbannedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountUnbannedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountUnbannedServiceServer()
}

func RegisterUserAccountUserAccountUnbannedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountUnbannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountUnbannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountUnbannedService_ServiceDesc, srv)
}

func _UserAccountUserAccountUnbannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountUnbanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountUnbannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountUnbannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountUnbannedServiceServer).OnMessage(ctx, req.(*UserAccountUnbanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountUnbannedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountUnbannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountUnbannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountUnbannedService",
	HandlerType: (*UserAccountUserAccountUnbannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountUnbannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountVerifiedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountVerifiedService/OnMessage"
)

// UserAccountUserAccountVerifiedServiceClient is the client API for UserAccountUserAccountVerifiedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountVerified to the User Account channel. (oneOf variant) (userAccount UserAccountVerified)
type UserAccountUserAccountVerifiedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountVerified, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountVerifiedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountVerifiedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountVerifiedServiceClient {
	return &userAccountUserAccountVerifiedServiceClient{cc}
}

func (c *userAccountUserAccountVerifiedServiceClient) OnMessage(ctx context.Context, in *UserAccountVerified, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountVerifiedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountVerifiedServiceServer is the server API for UserAccountUserAccountVerifiedService service.
// All implementations should embed UnimplementedUserAccountUserAccountVerifiedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountVerified to the User Account channel. (oneOf variant) (userAccount UserAccountVerified)
type UserAccountUserAccountVerifiedServiceServer interface {
	OnMessage(context.Context, *UserAccountVerified) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountVerifiedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountVerifiedServiceServer struct{}

func (UnimplementedUserAccountUserAccountVerifiedServiceServer) OnMessage(context.Context, *UserAccountVerified) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountVerifiedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountVerifiedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountVerifiedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountVerifiedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountVerifiedServiceServer()
}

func RegisterUserAccountUserAccountVerifiedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountVerifiedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountVerifiedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountVerifiedService_ServiceDesc, srv)
}

func _UserAccountUserAccountVerifiedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountVerified)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountVerifiedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountVerifiedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountVerifiedServiceServer).OnMessage(ctx, req.(*UserAccountVerified))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountVerifiedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountVerifiedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountVerifiedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountVerifiedService",
	HandlerType: (*UserAccountUserAccountVerifiedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountVerifiedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountLinkedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountLinkedService/OnMessage"
)

// UserAccountUserAccountLinkedServiceClient is the client API for UserAccountUserAccountLinkedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountLinked to the User Account channel. (oneOf variant) (userAccount UserAccountLinked)
type UserAccountUserAccountLinkedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountLinked, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountLinkedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountLinkedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountLinkedServiceClient {
	return &userAccountUserAccountLinkedServiceClient{cc}
}

func (c *userAccountUserAccountLinkedServiceClient) OnMessage(ctx context.Context, in *UserAccountLinked, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountLinkedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountLinkedServiceServer is the server API for UserAccountUserAccountLinkedService service.
// All implementations should embed UnimplementedUserAccountUserAccountLinkedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountLinked to the User Account channel. (oneOf variant) (userAccount UserAccountLinked)
type UserAccountUserAccountLinkedServiceServer interface {
	OnMessage(context.Context, *UserAccountLinked) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountLinkedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountLinkedServiceServer struct{}

func (UnimplementedUserAccountUserAccountLinkedServiceServer) OnMessage(context.Context, *UserAccountLinked) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountLinkedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountLinkedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountLinkedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountLinkedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountLinkedServiceServer()
}

func RegisterUserAccountUserAccountLinkedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountLinkedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountLinkedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountLinkedService_ServiceDesc, srv)
}

func _UserAccountUserAccountLinkedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountLinked)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountLinkedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountLinkedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountLinkedServiceServer).OnMessage(ctx, req.(*UserAccountLinked))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountLinkedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountLinkedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountLinkedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountLinkedService",
	HandlerType: (*UserAccountUserAccountLinkedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountLinkedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountUnlinkedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountUnlinkedService/OnMessage"
)

// UserAccountUserAccountUnlinkedServiceClient is the client API for UserAccountUserAccountUnlinkedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountUnlinked to the User Account channel. (oneOf variant) (userAccount UserAccountUnlinked)
type UserAccountUserAccountUnlinkedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountUnlinked, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountUnlinkedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountUnlinkedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountUnlinkedServiceClient {
	return &userAccountUserAccountUnlinkedServiceClient{cc}
}

func (c *userAccountUserAccountUnlinkedServiceClient) OnMessage(ctx context.Context, in *UserAccountUnlinked, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountUnlinkedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountUnlinkedServiceServer is the server API for UserAccountUserAccountUnlinkedService service.
// All implementations should embed UnimplementedUserAccountUserAccountUnlinkedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountUnlinked to the User Account channel. (oneOf variant) (userAccount UserAccountUnlinked)
type UserAccountUserAccountUnlinkedServiceServer interface {
	OnMessage(context.Context, *UserAccountUnlinked) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountUnlinkedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountUnlinkedServiceServer struct{}

func (UnimplementedUserAccountUserAccountUnlinkedServiceServer) OnMessage(context.Context, *UserAccountUnlinked) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountUnlinkedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountUnlinkedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountUnlinkedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountUnlinkedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountUnlinkedServiceServer()
}

func RegisterUserAccountUserAccountUnlinkedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountUnlinkedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountUnlinkedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountUnlinkedService_ServiceDesc, srv)
}

func _UserAccountUserAccountUnlinkedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountUnlinked)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountUnlinkedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountUnlinkedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountUnlinkedServiceServer).OnMessage(ctx, req.(*UserAccountUnlinked))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountUnlinkedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountUnlinkedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountUnlinkedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountUnlinkedService",
	HandlerType: (*UserAccountUserAccountUnlinkedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountUnlinkedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountUpgradedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountUpgradedService/OnMessage"
)

// UserAccountUserAccountUpgradedServiceClient is the client API for UserAccountUserAccountUpgradedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountUpgraded to the User Account channel. (oneOf variant) (userAccount UserAccountUpgraded)
type UserAccountUserAccountUpgradedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountUpgraded, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountUpgradedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountUpgradedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountUpgradedServiceClient {
	return &userAccountUserAccountUpgradedServiceClient{cc}
}

func (c *userAccountUserAccountUpgradedServiceClient) OnMessage(ctx context.Context, in *UserAccountUpgraded, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountUpgradedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountUpgradedServiceServer is the server API for UserAccountUserAccountUpgradedService service.
// All implementations should embed UnimplementedUserAccountUserAccountUpgradedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountUpgraded to the User Account channel. (oneOf variant) (userAccount UserAccountUpgraded)
type UserAccountUserAccountUpgradedServiceServer interface {
	OnMessage(context.Context, *UserAccountUpgraded) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountUpgradedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountUpgradedServiceServer struct{}

func (UnimplementedUserAccountUserAccountUpgradedServiceServer) OnMessage(context.Context, *UserAccountUpgraded) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountUpgradedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountUpgradedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountUpgradedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountUpgradedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountUpgradedServiceServer()
}

func RegisterUserAccountUserAccountUpgradedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountUpgradedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountUpgradedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountUpgradedService_ServiceDesc, srv)
}

func _UserAccountUserAccountUpgradedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountUpgraded)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountUpgradedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountUpgradedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountUpgradedServiceServer).OnMessage(ctx, req.(*UserAccountUpgraded))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountUpgradedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountUpgradedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountUpgradedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountUpgradedService",
	HandlerType: (*UserAccountUserAccountUpgradedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountUpgradedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountGameUserAccountCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountGameUserAccountCreatedService/OnMessage"
)

// UserAccountGameUserAccountCreatedServiceClient is the client API for UserAccountGameUserAccountCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a GameUserAccountCreated to the User Account channel. (oneOf variant) (userAccount GameUserAccountCreated)
type UserAccountGameUserAccountCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *GameUserAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountGameUserAccountCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountGameUserAccountCreatedServiceClient(cc grpc.ClientConnInterface) UserAccountGameUserAccountCreatedServiceClient {
	return &userAccountGameUserAccountCreatedServiceClient{cc}
}

func (c *userAccountGameUserAccountCreatedServiceClient) OnMessage(ctx context.Context, in *GameUserAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountGameUserAccountCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountGameUserAccountCreatedServiceServer is the server API for UserAccountGameUserAccountCreatedService service.
// All implementations should embed UnimplementedUserAccountGameUserAccountCreatedServiceServer
// for forward compatibility.
//
// Publishes a GameUserAccountCreated to the User Account channel. (oneOf variant) (userAccount GameUserAccountCreated)
type UserAccountGameUserAccountCreatedServiceServer interface {
	OnMessage(context.Context, *GameUserAccountCreated) (*emptypb.Empty, error)
}

// UnimplementedUserAccountGameUserAccountCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountGameUserAccountCreatedServiceServer struct{}

func (UnimplementedUserAccountGameUserAccountCreatedServiceServer) OnMessage(context.Context, *GameUserAccountCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountGameUserAccountCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountGameUserAccountCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountGameUserAccountCreatedServiceServer will
// result in compilation errors.
type UnsafeUserAccountGameUserAccountCreatedServiceServer interface {
	mustEmbedUnimplementedUserAccountGameUserAccountCreatedServiceServer()
}

func RegisterUserAccountGameUserAccountCreatedServiceServer(s grpc.ServiceRegistrar, srv UserAccountGameUserAccountCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountGameUserAccountCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountGameUserAccountCreatedService_ServiceDesc, srv)
}

func _UserAccountGameUserAccountCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserAccountCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountGameUserAccountCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountGameUserAccountCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountGameUserAccountCreatedServiceServer).OnMessage(ctx, req.(*GameUserAccountCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountGameUserAccountCreatedService_ServiceDesc is the grpc.ServiceDesc for UserAccountGameUserAccountCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountGameUserAccountCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountGameUserAccountCreatedService",
	HandlerType: (*UserAccountGameUserAccountCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountGameUserAccountCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountThirdPartyAccountCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountThirdPartyAccountCreatedService/OnMessage"
)

// UserAccountThirdPartyAccountCreatedServiceClient is the client API for UserAccountThirdPartyAccountCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a ThirdPartyAccountCreated to the User Account channel. (oneOf variant) (userAccount ThirdPartyAccountCreated)
type UserAccountThirdPartyAccountCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *ThirdPartyAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountThirdPartyAccountCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountThirdPartyAccountCreatedServiceClient(cc grpc.ClientConnInterface) UserAccountThirdPartyAccountCreatedServiceClient {
	return &userAccountThirdPartyAccountCreatedServiceClient{cc}
}

func (c *userAccountThirdPartyAccountCreatedServiceClient) OnMessage(ctx context.Context, in *ThirdPartyAccountCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountThirdPartyAccountCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountThirdPartyAccountCreatedServiceServer is the server API for UserAccountThirdPartyAccountCreatedService service.
// All implementations should embed UnimplementedUserAccountThirdPartyAccountCreatedServiceServer
// for forward compatibility.
//
// Publishes a ThirdPartyAccountCreated to the User Account channel. (oneOf variant) (userAccount ThirdPartyAccountCreated)
type UserAccountThirdPartyAccountCreatedServiceServer interface {
	OnMessage(context.Context, *ThirdPartyAccountCreated) (*emptypb.Empty, error)
}

// UnimplementedUserAccountThirdPartyAccountCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountThirdPartyAccountCreatedServiceServer struct{}

func (UnimplementedUserAccountThirdPartyAccountCreatedServiceServer) OnMessage(context.Context, *ThirdPartyAccountCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountThirdPartyAccountCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountThirdPartyAccountCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountThirdPartyAccountCreatedServiceServer will
// result in compilation errors.
type UnsafeUserAccountThirdPartyAccountCreatedServiceServer interface {
	mustEmbedUnimplementedUserAccountThirdPartyAccountCreatedServiceServer()
}

func RegisterUserAccountThirdPartyAccountCreatedServiceServer(s grpc.ServiceRegistrar, srv UserAccountThirdPartyAccountCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountThirdPartyAccountCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountThirdPartyAccountCreatedService_ServiceDesc, srv)
}

func _UserAccountThirdPartyAccountCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ThirdPartyAccountCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountThirdPartyAccountCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountThirdPartyAccountCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountThirdPartyAccountCreatedServiceServer).OnMessage(ctx, req.(*ThirdPartyAccountCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountThirdPartyAccountCreatedService_ServiceDesc is the grpc.ServiceDesc for UserAccountThirdPartyAccountCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountThirdPartyAccountCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountThirdPartyAccountCreatedService",
	HandlerType: (*UserAccountThirdPartyAccountCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountThirdPartyAccountCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAccountUserAccountTypeChangedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAccountUserAccountTypeChangedService/OnMessage"
)

// UserAccountUserAccountTypeChangedServiceClient is the client API for UserAccountUserAccountTypeChangedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserAccountTypeChanged to the User Account channel. (oneOf variant) (userAccount UserAccountTypeChanged)
type UserAccountUserAccountTypeChangedServiceClient interface {
	OnMessage(ctx context.Context, in *UserAccountTypeChanged, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAccountUserAccountTypeChangedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAccountUserAccountTypeChangedServiceClient(cc grpc.ClientConnInterface) UserAccountUserAccountTypeChangedServiceClient {
	return &userAccountUserAccountTypeChangedServiceClient{cc}
}

func (c *userAccountUserAccountTypeChangedServiceClient) OnMessage(ctx context.Context, in *UserAccountTypeChanged, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAccountUserAccountTypeChangedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAccountUserAccountTypeChangedServiceServer is the server API for UserAccountUserAccountTypeChangedService service.
// All implementations should embed UnimplementedUserAccountUserAccountTypeChangedServiceServer
// for forward compatibility.
//
// Publishes a UserAccountTypeChanged to the User Account channel. (oneOf variant) (userAccount UserAccountTypeChanged)
type UserAccountUserAccountTypeChangedServiceServer interface {
	OnMessage(context.Context, *UserAccountTypeChanged) (*emptypb.Empty, error)
}

// UnimplementedUserAccountUserAccountTypeChangedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAccountUserAccountTypeChangedServiceServer struct{}

func (UnimplementedUserAccountUserAccountTypeChangedServiceServer) OnMessage(context.Context, *UserAccountTypeChanged) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAccountUserAccountTypeChangedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAccountUserAccountTypeChangedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAccountUserAccountTypeChangedServiceServer will
// result in compilation errors.
type UnsafeUserAccountUserAccountTypeChangedServiceServer interface {
	mustEmbedUnimplementedUserAccountUserAccountTypeChangedServiceServer()
}

func RegisterUserAccountUserAccountTypeChangedServiceServer(s grpc.ServiceRegistrar, srv UserAccountUserAccountTypeChangedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAccountUserAccountTypeChangedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAccountUserAccountTypeChangedService_ServiceDesc, srv)
}

func _UserAccountUserAccountTypeChangedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAccountTypeChanged)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAccountUserAccountTypeChangedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAccountUserAccountTypeChangedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAccountUserAccountTypeChangedServiceServer).OnMessage(ctx, req.(*UserAccountTypeChanged))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAccountUserAccountTypeChangedService_ServiceDesc is the grpc.ServiceDesc for UserAccountUserAccountTypeChangedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAccountUserAccountTypeChangedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAccountUserAccountTypeChangedService",
	HandlerType: (*UserAccountUserAccountTypeChangedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAccountUserAccountTypeChangedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAuthenticationUserLoggedInService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAuthenticationUserLoggedInService/OnMessage"
)

// UserAuthenticationUserLoggedInServiceClient is the client API for UserAuthenticationUserLoggedInService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserLoggedIn to the User Authentication channel. (oneOf variant) (userAuthentication UserLoggedIn)
type UserAuthenticationUserLoggedInServiceClient interface {
	OnMessage(ctx context.Context, in *UserLoggedIn, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAuthenticationUserLoggedInServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAuthenticationUserLoggedInServiceClient(cc grpc.ClientConnInterface) UserAuthenticationUserLoggedInServiceClient {
	return &userAuthenticationUserLoggedInServiceClient{cc}
}

func (c *userAuthenticationUserLoggedInServiceClient) OnMessage(ctx context.Context, in *UserLoggedIn, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAuthenticationUserLoggedInService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAuthenticationUserLoggedInServiceServer is the server API for UserAuthenticationUserLoggedInService service.
// All implementations should embed UnimplementedUserAuthenticationUserLoggedInServiceServer
// for forward compatibility.
//
// Publishes a UserLoggedIn to the User Authentication channel. (oneOf variant) (userAuthentication UserLoggedIn)
type UserAuthenticationUserLoggedInServiceServer interface {
	OnMessage(context.Context, *UserLoggedIn) (*emptypb.Empty, error)
}

// UnimplementedUserAuthenticationUserLoggedInServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAuthenticationUserLoggedInServiceServer struct{}

func (UnimplementedUserAuthenticationUserLoggedInServiceServer) OnMessage(context.Context, *UserLoggedIn) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAuthenticationUserLoggedInServiceServer) testEmbeddedByValue() {}

// UnsafeUserAuthenticationUserLoggedInServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAuthenticationUserLoggedInServiceServer will
// result in compilation errors.
type UnsafeUserAuthenticationUserLoggedInServiceServer interface {
	mustEmbedUnimplementedUserAuthenticationUserLoggedInServiceServer()
}

func RegisterUserAuthenticationUserLoggedInServiceServer(s grpc.ServiceRegistrar, srv UserAuthenticationUserLoggedInServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAuthenticationUserLoggedInServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAuthenticationUserLoggedInService_ServiceDesc, srv)
}

func _UserAuthenticationUserLoggedInService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoggedIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAuthenticationUserLoggedInServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAuthenticationUserLoggedInService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAuthenticationUserLoggedInServiceServer).OnMessage(ctx, req.(*UserLoggedIn))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAuthenticationUserLoggedInService_ServiceDesc is the grpc.ServiceDesc for UserAuthenticationUserLoggedInService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAuthenticationUserLoggedInService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAuthenticationUserLoggedInService",
	HandlerType: (*UserAuthenticationUserLoggedInServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAuthenticationUserLoggedInService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAuthenticationUserLoggedOutService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAuthenticationUserLoggedOutService/OnMessage"
)

// UserAuthenticationUserLoggedOutServiceClient is the client API for UserAuthenticationUserLoggedOutService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserLoggedOut to the User Authentication channel. (oneOf variant) (userAuthentication UserLoggedOut)
type UserAuthenticationUserLoggedOutServiceClient interface {
	OnMessage(ctx context.Context, in *UserLoggedOut, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAuthenticationUserLoggedOutServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAuthenticationUserLoggedOutServiceClient(cc grpc.ClientConnInterface) UserAuthenticationUserLoggedOutServiceClient {
	return &userAuthenticationUserLoggedOutServiceClient{cc}
}

func (c *userAuthenticationUserLoggedOutServiceClient) OnMessage(ctx context.Context, in *UserLoggedOut, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAuthenticationUserLoggedOutService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAuthenticationUserLoggedOutServiceServer is the server API for UserAuthenticationUserLoggedOutService service.
// All implementations should embed UnimplementedUserAuthenticationUserLoggedOutServiceServer
// for forward compatibility.
//
// Publishes a UserLoggedOut to the User Authentication channel. (oneOf variant) (userAuthentication UserLoggedOut)
type UserAuthenticationUserLoggedOutServiceServer interface {
	OnMessage(context.Context, *UserLoggedOut) (*emptypb.Empty, error)
}

// UnimplementedUserAuthenticationUserLoggedOutServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAuthenticationUserLoggedOutServiceServer struct{}

func (UnimplementedUserAuthenticationUserLoggedOutServiceServer) OnMessage(context.Context, *UserLoggedOut) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAuthenticationUserLoggedOutServiceServer) testEmbeddedByValue() {}

// UnsafeUserAuthenticationUserLoggedOutServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAuthenticationUserLoggedOutServiceServer will
// result in compilation errors.
type UnsafeUserAuthenticationUserLoggedOutServiceServer interface {
	mustEmbedUnimplementedUserAuthenticationUserLoggedOutServiceServer()
}

func RegisterUserAuthenticationUserLoggedOutServiceServer(s grpc.ServiceRegistrar, srv UserAuthenticationUserLoggedOutServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAuthenticationUserLoggedOutServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAuthenticationUserLoggedOutService_ServiceDesc, srv)
}

func _UserAuthenticationUserLoggedOutService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoggedOut)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAuthenticationUserLoggedOutServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAuthenticationUserLoggedOutService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAuthenticationUserLoggedOutServiceServer).OnMessage(ctx, req.(*UserLoggedOut))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAuthenticationUserLoggedOutService_ServiceDesc is the grpc.ServiceDesc for UserAuthenticationUserLoggedOutService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAuthenticationUserLoggedOutService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAuthenticationUserLoggedOutService",
	HandlerType: (*UserAuthenticationUserLoggedOutServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAuthenticationUserLoggedOutService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAuthenticationUserThirdPartyLoggedInService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAuthenticationUserThirdPartyLoggedInService/OnMessage"
)

// UserAuthenticationUserThirdPartyLoggedInServiceClient is the client API for UserAuthenticationUserThirdPartyLoggedInService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserThirdPartyLoggedIn to the User Authentication channel. (oneOf variant) (userAuthentication UserThirdPartyLoggedIn)
type UserAuthenticationUserThirdPartyLoggedInServiceClient interface {
	OnMessage(ctx context.Context, in *UserThirdPartyLoggedIn, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAuthenticationUserThirdPartyLoggedInServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAuthenticationUserThirdPartyLoggedInServiceClient(cc grpc.ClientConnInterface) UserAuthenticationUserThirdPartyLoggedInServiceClient {
	return &userAuthenticationUserThirdPartyLoggedInServiceClient{cc}
}

func (c *userAuthenticationUserThirdPartyLoggedInServiceClient) OnMessage(ctx context.Context, in *UserThirdPartyLoggedIn, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAuthenticationUserThirdPartyLoggedInService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAuthenticationUserThirdPartyLoggedInServiceServer is the server API for UserAuthenticationUserThirdPartyLoggedInService service.
// All implementations should embed UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer
// for forward compatibility.
//
// Publishes a UserThirdPartyLoggedIn to the User Authentication channel. (oneOf variant) (userAuthentication UserThirdPartyLoggedIn)
type UserAuthenticationUserThirdPartyLoggedInServiceServer interface {
	OnMessage(context.Context, *UserThirdPartyLoggedIn) (*emptypb.Empty, error)
}

// UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer struct{}

func (UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer) OnMessage(context.Context, *UserThirdPartyLoggedIn) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer) testEmbeddedByValue() {}

// UnsafeUserAuthenticationUserThirdPartyLoggedInServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAuthenticationUserThirdPartyLoggedInServiceServer will
// result in compilation errors.
type UnsafeUserAuthenticationUserThirdPartyLoggedInServiceServer interface {
	mustEmbedUnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer()
}

func RegisterUserAuthenticationUserThirdPartyLoggedInServiceServer(s grpc.ServiceRegistrar, srv UserAuthenticationUserThirdPartyLoggedInServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAuthenticationUserThirdPartyLoggedInServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAuthenticationUserThirdPartyLoggedInService_ServiceDesc, srv)
}

func _UserAuthenticationUserThirdPartyLoggedInService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserThirdPartyLoggedIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAuthenticationUserThirdPartyLoggedInServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAuthenticationUserThirdPartyLoggedInService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAuthenticationUserThirdPartyLoggedInServiceServer).OnMessage(ctx, req.(*UserThirdPartyLoggedIn))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAuthenticationUserThirdPartyLoggedInService_ServiceDesc is the grpc.ServiceDesc for UserAuthenticationUserThirdPartyLoggedInService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAuthenticationUserThirdPartyLoggedInService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAuthenticationUserThirdPartyLoggedInService",
	HandlerType: (*UserAuthenticationUserThirdPartyLoggedInServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAuthenticationUserThirdPartyLoggedInService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAuthenticationUserLoginFailedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAuthenticationUserLoginFailedService/OnMessage"
)

// UserAuthenticationUserLoginFailedServiceClient is the client API for UserAuthenticationUserLoginFailedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserLoginFailed to the User Authentication channel. (oneOf variant) (userAuthentication UserLoginFailed)
type UserAuthenticationUserLoginFailedServiceClient interface {
	OnMessage(ctx context.Context, in *UserLoginFailed, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAuthenticationUserLoginFailedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAuthenticationUserLoginFailedServiceClient(cc grpc.ClientConnInterface) UserAuthenticationUserLoginFailedServiceClient {
	return &userAuthenticationUserLoginFailedServiceClient{cc}
}

func (c *userAuthenticationUserLoginFailedServiceClient) OnMessage(ctx context.Context, in *UserLoginFailed, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAuthenticationUserLoginFailedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAuthenticationUserLoginFailedServiceServer is the server API for UserAuthenticationUserLoginFailedService service.
// All implementations should embed UnimplementedUserAuthenticationUserLoginFailedServiceServer
// for forward compatibility.
//
// Publishes a UserLoginFailed to the User Authentication channel. (oneOf variant) (userAuthentication UserLoginFailed)
type UserAuthenticationUserLoginFailedServiceServer interface {
	OnMessage(context.Context, *UserLoginFailed) (*emptypb.Empty, error)
}

// UnimplementedUserAuthenticationUserLoginFailedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAuthenticationUserLoginFailedServiceServer struct{}

func (UnimplementedUserAuthenticationUserLoginFailedServiceServer) OnMessage(context.Context, *UserLoginFailed) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAuthenticationUserLoginFailedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAuthenticationUserLoginFailedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAuthenticationUserLoginFailedServiceServer will
// result in compilation errors.
type UnsafeUserAuthenticationUserLoginFailedServiceServer interface {
	mustEmbedUnimplementedUserAuthenticationUserLoginFailedServiceServer()
}

func RegisterUserAuthenticationUserLoginFailedServiceServer(s grpc.ServiceRegistrar, srv UserAuthenticationUserLoginFailedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAuthenticationUserLoginFailedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAuthenticationUserLoginFailedService_ServiceDesc, srv)
}

func _UserAuthenticationUserLoginFailedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAuthenticationUserLoginFailedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAuthenticationUserLoginFailedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAuthenticationUserLoginFailedServiceServer).OnMessage(ctx, req.(*UserLoginFailed))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAuthenticationUserLoginFailedService_ServiceDesc is the grpc.ServiceDesc for UserAuthenticationUserLoginFailedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAuthenticationUserLoginFailedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAuthenticationUserLoginFailedService",
	HandlerType: (*UserAuthenticationUserLoginFailedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAuthenticationUserLoginFailedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserAuthenticationUserThirdPartyLoginFailedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserAuthenticationUserThirdPartyLoginFailedService/OnMessage"
)

// UserAuthenticationUserThirdPartyLoginFailedServiceClient is the client API for UserAuthenticationUserThirdPartyLoginFailedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserThirdPartyLoginFailed to the User Authentication channel. (oneOf variant) (userAuthentication UserThirdPartyLoginFailed)
type UserAuthenticationUserThirdPartyLoginFailedServiceClient interface {
	OnMessage(ctx context.Context, in *UserThirdPartyLoginFailed, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userAuthenticationUserThirdPartyLoginFailedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserAuthenticationUserThirdPartyLoginFailedServiceClient(cc grpc.ClientConnInterface) UserAuthenticationUserThirdPartyLoginFailedServiceClient {
	return &userAuthenticationUserThirdPartyLoginFailedServiceClient{cc}
}

func (c *userAuthenticationUserThirdPartyLoginFailedServiceClient) OnMessage(ctx context.Context, in *UserThirdPartyLoginFailed, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserAuthenticationUserThirdPartyLoginFailedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserAuthenticationUserThirdPartyLoginFailedServiceServer is the server API for UserAuthenticationUserThirdPartyLoginFailedService service.
// All implementations should embed UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer
// for forward compatibility.
//
// Publishes a UserThirdPartyLoginFailed to the User Authentication channel. (oneOf variant) (userAuthentication UserThirdPartyLoginFailed)
type UserAuthenticationUserThirdPartyLoginFailedServiceServer interface {
	OnMessage(context.Context, *UserThirdPartyLoginFailed) (*emptypb.Empty, error)
}

// UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer struct{}

func (UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer) OnMessage(context.Context, *UserThirdPartyLoginFailed) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer) testEmbeddedByValue() {}

// UnsafeUserAuthenticationUserThirdPartyLoginFailedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserAuthenticationUserThirdPartyLoginFailedServiceServer will
// result in compilation errors.
type UnsafeUserAuthenticationUserThirdPartyLoginFailedServiceServer interface {
	mustEmbedUnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer()
}

func RegisterUserAuthenticationUserThirdPartyLoginFailedServiceServer(s grpc.ServiceRegistrar, srv UserAuthenticationUserThirdPartyLoginFailedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserAuthenticationUserThirdPartyLoginFailedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserAuthenticationUserThirdPartyLoginFailedService_ServiceDesc, srv)
}

func _UserAuthenticationUserThirdPartyLoginFailedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserThirdPartyLoginFailed)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserAuthenticationUserThirdPartyLoginFailedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserAuthenticationUserThirdPartyLoginFailedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserAuthenticationUserThirdPartyLoginFailedServiceServer).OnMessage(ctx, req.(*UserThirdPartyLoginFailed))
	}
	return interceptor(ctx, in, info, handler)
}

// UserAuthenticationUserThirdPartyLoginFailedService_ServiceDesc is the grpc.ServiceDesc for UserAuthenticationUserThirdPartyLoginFailedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserAuthenticationUserThirdPartyLoginFailedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserAuthenticationUserThirdPartyLoginFailedService",
	HandlerType: (*UserAuthenticationUserThirdPartyLoginFailedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserAuthenticationUserThirdPartyLoginFailedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationCreatedService/OnMessage"
)

// UserInformationUserInformationCreatedServiceClient is the client API for UserInformationUserInformationCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationCreated to the User Information channel. (oneOf variant) (userInformation UserInformationCreated)
type UserInformationUserInformationCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationCreatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationCreatedServiceClient {
	return &userInformationUserInformationCreatedServiceClient{cc}
}

func (c *userInformationUserInformationCreatedServiceClient) OnMessage(ctx context.Context, in *UserInformationCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationCreatedServiceServer is the server API for UserInformationUserInformationCreatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationCreatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationCreated to the User Information channel. (oneOf variant) (userInformation UserInformationCreated)
type UserInformationUserInformationCreatedServiceServer interface {
	OnMessage(context.Context, *UserInformationCreated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationCreatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationCreatedServiceServer) OnMessage(context.Context, *UserInformationCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserInformationUserInformationCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationCreatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationCreatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationCreatedServiceServer()
}

func RegisterUserInformationUserInformationCreatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationCreatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationCreatedServiceServer).OnMessage(ctx, req.(*UserInformationCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationCreatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationCreatedService",
	HandlerType: (*UserInformationUserInformationCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationDisplayNameUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationDisplayNameUpdatedService/OnMessage"
)

// UserInformationUserInformationDisplayNameUpdatedServiceClient is the client API for UserInformationUserInformationDisplayNameUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationDisplayNameUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationDisplayNameUpdated)
type UserInformationUserInformationDisplayNameUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationDisplayNameUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationDisplayNameUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationDisplayNameUpdatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationDisplayNameUpdatedServiceClient {
	return &userInformationUserInformationDisplayNameUpdatedServiceClient{cc}
}

func (c *userInformationUserInformationDisplayNameUpdatedServiceClient) OnMessage(ctx context.Context, in *UserInformationDisplayNameUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationDisplayNameUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationDisplayNameUpdatedServiceServer is the server API for UserInformationUserInformationDisplayNameUpdatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationDisplayNameUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationDisplayNameUpdated)
type UserInformationUserInformationDisplayNameUpdatedServiceServer interface {
	OnMessage(context.Context, *UserInformationDisplayNameUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer) OnMessage(context.Context, *UserInformationDisplayNameUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer) testEmbeddedByValue() {
}

// UnsafeUserInformationUserInformationDisplayNameUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationDisplayNameUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationDisplayNameUpdatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer()
}

func RegisterUserInformationUserInformationDisplayNameUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationDisplayNameUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationDisplayNameUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationDisplayNameUpdatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationDisplayNameUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationDisplayNameUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationDisplayNameUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationDisplayNameUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationDisplayNameUpdatedServiceServer).OnMessage(ctx, req.(*UserInformationDisplayNameUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationDisplayNameUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationDisplayNameUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationDisplayNameUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationDisplayNameUpdatedService",
	HandlerType: (*UserInformationUserInformationDisplayNameUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationDisplayNameUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationCountryUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationCountryUpdatedService/OnMessage"
)

// UserInformationUserInformationCountryUpdatedServiceClient is the client API for UserInformationUserInformationCountryUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationCountryUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationCountryUpdated)
type UserInformationUserInformationCountryUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationCountryUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationCountryUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationCountryUpdatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationCountryUpdatedServiceClient {
	return &userInformationUserInformationCountryUpdatedServiceClient{cc}
}

func (c *userInformationUserInformationCountryUpdatedServiceClient) OnMessage(ctx context.Context, in *UserInformationCountryUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationCountryUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationCountryUpdatedServiceServer is the server API for UserInformationUserInformationCountryUpdatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationCountryUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationCountryUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationCountryUpdated)
type UserInformationUserInformationCountryUpdatedServiceServer interface {
	OnMessage(context.Context, *UserInformationCountryUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationCountryUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationCountryUpdatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationCountryUpdatedServiceServer) OnMessage(context.Context, *UserInformationCountryUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationCountryUpdatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserInformationUserInformationCountryUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationCountryUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationCountryUpdatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationCountryUpdatedServiceServer()
}

func RegisterUserInformationUserInformationCountryUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationCountryUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationCountryUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationCountryUpdatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationCountryUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationCountryUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationCountryUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationCountryUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationCountryUpdatedServiceServer).OnMessage(ctx, req.(*UserInformationCountryUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationCountryUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationCountryUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationCountryUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationCountryUpdatedService",
	HandlerType: (*UserInformationUserInformationCountryUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationCountryUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationLanguageUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationLanguageUpdatedService/OnMessage"
)

// UserInformationUserInformationLanguageUpdatedServiceClient is the client API for UserInformationUserInformationLanguageUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationLanguageUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationLanguageUpdated)
type UserInformationUserInformationLanguageUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationLanguageUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationLanguageUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationLanguageUpdatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationLanguageUpdatedServiceClient {
	return &userInformationUserInformationLanguageUpdatedServiceClient{cc}
}

func (c *userInformationUserInformationLanguageUpdatedServiceClient) OnMessage(ctx context.Context, in *UserInformationLanguageUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationLanguageUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationLanguageUpdatedServiceServer is the server API for UserInformationUserInformationLanguageUpdatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationLanguageUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationLanguageUpdated)
type UserInformationUserInformationLanguageUpdatedServiceServer interface {
	OnMessage(context.Context, *UserInformationLanguageUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer) OnMessage(context.Context, *UserInformationLanguageUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer) testEmbeddedByValue() {
}

// UnsafeUserInformationUserInformationLanguageUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationLanguageUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationLanguageUpdatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationLanguageUpdatedServiceServer()
}

func RegisterUserInformationUserInformationLanguageUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationLanguageUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationLanguageUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationLanguageUpdatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationLanguageUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationLanguageUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationLanguageUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationLanguageUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationLanguageUpdatedServiceServer).OnMessage(ctx, req.(*UserInformationLanguageUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationLanguageUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationLanguageUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationLanguageUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationLanguageUpdatedService",
	HandlerType: (*UserInformationUserInformationLanguageUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationLanguageUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationDateOfBirthUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationDateOfBirthUpdatedService/OnMessage"
)

// UserInformationUserInformationDateOfBirthUpdatedServiceClient is the client API for UserInformationUserInformationDateOfBirthUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationDateOfBirthUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationDateOfBirthUpdated)
type UserInformationUserInformationDateOfBirthUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationDateOfBirthUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationDateOfBirthUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationDateOfBirthUpdatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationDateOfBirthUpdatedServiceClient {
	return &userInformationUserInformationDateOfBirthUpdatedServiceClient{cc}
}

func (c *userInformationUserInformationDateOfBirthUpdatedServiceClient) OnMessage(ctx context.Context, in *UserInformationDateOfBirthUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationDateOfBirthUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationDateOfBirthUpdatedServiceServer is the server API for UserInformationUserInformationDateOfBirthUpdatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationDateOfBirthUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationDateOfBirthUpdated)
type UserInformationUserInformationDateOfBirthUpdatedServiceServer interface {
	OnMessage(context.Context, *UserInformationDateOfBirthUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer) OnMessage(context.Context, *UserInformationDateOfBirthUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer) testEmbeddedByValue() {
}

// UnsafeUserInformationUserInformationDateOfBirthUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationDateOfBirthUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationDateOfBirthUpdatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer()
}

func RegisterUserInformationUserInformationDateOfBirthUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationDateOfBirthUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationDateOfBirthUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationDateOfBirthUpdatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationDateOfBirthUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationDateOfBirthUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationDateOfBirthUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationDateOfBirthUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationDateOfBirthUpdatedServiceServer).OnMessage(ctx, req.(*UserInformationDateOfBirthUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationDateOfBirthUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationDateOfBirthUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationDateOfBirthUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationDateOfBirthUpdatedService",
	HandlerType: (*UserInformationUserInformationDateOfBirthUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationDateOfBirthUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserInformationUserInformationUsernameUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserInformationUserInformationUsernameUpdatedService/OnMessage"
)

// UserInformationUserInformationUsernameUpdatedServiceClient is the client API for UserInformationUserInformationUsernameUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserInformationUsernameUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationUsernameUpdated)
type UserInformationUserInformationUsernameUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserInformationUsernameUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userInformationUserInformationUsernameUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserInformationUserInformationUsernameUpdatedServiceClient(cc grpc.ClientConnInterface) UserInformationUserInformationUsernameUpdatedServiceClient {
	return &userInformationUserInformationUsernameUpdatedServiceClient{cc}
}

func (c *userInformationUserInformationUsernameUpdatedServiceClient) OnMessage(ctx context.Context, in *UserInformationUsernameUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserInformationUserInformationUsernameUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserInformationUserInformationUsernameUpdatedServiceServer is the server API for UserInformationUserInformationUsernameUpdatedService service.
// All implementations should embed UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer
// for forward compatibility.
//
// Publishes a UserInformationUsernameUpdated to the User Information channel. (oneOf variant) (userInformation UserInformationUsernameUpdated)
type UserInformationUserInformationUsernameUpdatedServiceServer interface {
	OnMessage(context.Context, *UserInformationUsernameUpdated) (*emptypb.Empty, error)
}

// UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer struct{}

func (UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer) OnMessage(context.Context, *UserInformationUsernameUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer) testEmbeddedByValue() {
}

// UnsafeUserInformationUserInformationUsernameUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserInformationUserInformationUsernameUpdatedServiceServer will
// result in compilation errors.
type UnsafeUserInformationUserInformationUsernameUpdatedServiceServer interface {
	mustEmbedUnimplementedUserInformationUserInformationUsernameUpdatedServiceServer()
}

func RegisterUserInformationUserInformationUsernameUpdatedServiceServer(s grpc.ServiceRegistrar, srv UserInformationUserInformationUsernameUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserInformationUserInformationUsernameUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserInformationUserInformationUsernameUpdatedService_ServiceDesc, srv)
}

func _UserInformationUserInformationUsernameUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInformationUsernameUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserInformationUserInformationUsernameUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserInformationUserInformationUsernameUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserInformationUserInformationUsernameUpdatedServiceServer).OnMessage(ctx, req.(*UserInformationUsernameUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserInformationUserInformationUsernameUpdatedService_ServiceDesc is the grpc.ServiceDesc for UserInformationUserInformationUsernameUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserInformationUserInformationUsernameUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserInformationUserInformationUsernameUpdatedService",
	HandlerType: (*UserInformationUserInformationUsernameUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserInformationUserInformationUsernameUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserPermissionsUserPermissionsCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserPermissionsUserPermissionsCreatedService/OnMessage"
)

// UserPermissionsUserPermissionsCreatedServiceClient is the client API for UserPermissionsUserPermissionsCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserPermissionCreated to the User Permissions channel. (oneOf variant) (userPermissions UserPermissionsCreated)
type UserPermissionsUserPermissionsCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserPermissionCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userPermissionsUserPermissionsCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserPermissionsUserPermissionsCreatedServiceClient(cc grpc.ClientConnInterface) UserPermissionsUserPermissionsCreatedServiceClient {
	return &userPermissionsUserPermissionsCreatedServiceClient{cc}
}

func (c *userPermissionsUserPermissionsCreatedServiceClient) OnMessage(ctx context.Context, in *UserPermissionCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserPermissionsUserPermissionsCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserPermissionsUserPermissionsCreatedServiceServer is the server API for UserPermissionsUserPermissionsCreatedService service.
// All implementations should embed UnimplementedUserPermissionsUserPermissionsCreatedServiceServer
// for forward compatibility.
//
// Publishes a UserPermissionCreated to the User Permissions channel. (oneOf variant) (userPermissions UserPermissionsCreated)
type UserPermissionsUserPermissionsCreatedServiceServer interface {
	OnMessage(context.Context, *UserPermissionCreated) (*emptypb.Empty, error)
}

// UnimplementedUserPermissionsUserPermissionsCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserPermissionsUserPermissionsCreatedServiceServer struct{}

func (UnimplementedUserPermissionsUserPermissionsCreatedServiceServer) OnMessage(context.Context, *UserPermissionCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserPermissionsUserPermissionsCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserPermissionsUserPermissionsCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserPermissionsUserPermissionsCreatedServiceServer will
// result in compilation errors.
type UnsafeUserPermissionsUserPermissionsCreatedServiceServer interface {
	mustEmbedUnimplementedUserPermissionsUserPermissionsCreatedServiceServer()
}

func RegisterUserPermissionsUserPermissionsCreatedServiceServer(s grpc.ServiceRegistrar, srv UserPermissionsUserPermissionsCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserPermissionsUserPermissionsCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserPermissionsUserPermissionsCreatedService_ServiceDesc, srv)
}

func _UserPermissionsUserPermissionsCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPermissionCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPermissionsUserPermissionsCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserPermissionsUserPermissionsCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPermissionsUserPermissionsCreatedServiceServer).OnMessage(ctx, req.(*UserPermissionCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserPermissionsUserPermissionsCreatedService_ServiceDesc is the grpc.ServiceDesc for UserPermissionsUserPermissionsCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserPermissionsUserPermissionsCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserPermissionsUserPermissionsCreatedService",
	HandlerType: (*UserPermissionsUserPermissionsCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserPermissionsUserPermissionsCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserPermissionsUserPermissionsDeletedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserPermissionsUserPermissionsDeletedService/OnMessage"
)

// UserPermissionsUserPermissionsDeletedServiceClient is the client API for UserPermissionsUserPermissionsDeletedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserPermissionDeleted to the User Permissions channel. (oneOf variant) (userPermissions UserPermissionsDeleted)
type UserPermissionsUserPermissionsDeletedServiceClient interface {
	OnMessage(ctx context.Context, in *UserPermissionDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userPermissionsUserPermissionsDeletedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserPermissionsUserPermissionsDeletedServiceClient(cc grpc.ClientConnInterface) UserPermissionsUserPermissionsDeletedServiceClient {
	return &userPermissionsUserPermissionsDeletedServiceClient{cc}
}

func (c *userPermissionsUserPermissionsDeletedServiceClient) OnMessage(ctx context.Context, in *UserPermissionDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserPermissionsUserPermissionsDeletedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserPermissionsUserPermissionsDeletedServiceServer is the server API for UserPermissionsUserPermissionsDeletedService service.
// All implementations should embed UnimplementedUserPermissionsUserPermissionsDeletedServiceServer
// for forward compatibility.
//
// Publishes a UserPermissionDeleted to the User Permissions channel. (oneOf variant) (userPermissions UserPermissionsDeleted)
type UserPermissionsUserPermissionsDeletedServiceServer interface {
	OnMessage(context.Context, *UserPermissionDeleted) (*emptypb.Empty, error)
}

// UnimplementedUserPermissionsUserPermissionsDeletedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserPermissionsUserPermissionsDeletedServiceServer struct{}

func (UnimplementedUserPermissionsUserPermissionsDeletedServiceServer) OnMessage(context.Context, *UserPermissionDeleted) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserPermissionsUserPermissionsDeletedServiceServer) testEmbeddedByValue() {}

// UnsafeUserPermissionsUserPermissionsDeletedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserPermissionsUserPermissionsDeletedServiceServer will
// result in compilation errors.
type UnsafeUserPermissionsUserPermissionsDeletedServiceServer interface {
	mustEmbedUnimplementedUserPermissionsUserPermissionsDeletedServiceServer()
}

func RegisterUserPermissionsUserPermissionsDeletedServiceServer(s grpc.ServiceRegistrar, srv UserPermissionsUserPermissionsDeletedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserPermissionsUserPermissionsDeletedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserPermissionsUserPermissionsDeletedService_ServiceDesc, srv)
}

func _UserPermissionsUserPermissionsDeletedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPermissionDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserPermissionsUserPermissionsDeletedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserPermissionsUserPermissionsDeletedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserPermissionsUserPermissionsDeletedServiceServer).OnMessage(ctx, req.(*UserPermissionDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

// UserPermissionsUserPermissionsDeletedService_ServiceDesc is the grpc.ServiceDesc for UserPermissionsUserPermissionsDeletedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserPermissionsUserPermissionsDeletedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserPermissionsUserPermissionsDeletedService",
	HandlerType: (*UserPermissionsUserPermissionsDeletedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserPermissionsUserPermissionsDeletedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserRolesUserRolesCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserRolesUserRolesCreatedService/OnMessage"
)

// UserRolesUserRolesCreatedServiceClient is the client API for UserRolesUserRolesCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserRoleCreated to the User Roles channel. (oneOf variant) (userRoles UserRolesCreated)
type UserRolesUserRolesCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *UserRoleCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userRolesUserRolesCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRolesUserRolesCreatedServiceClient(cc grpc.ClientConnInterface) UserRolesUserRolesCreatedServiceClient {
	return &userRolesUserRolesCreatedServiceClient{cc}
}

func (c *userRolesUserRolesCreatedServiceClient) OnMessage(ctx context.Context, in *UserRoleCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRolesUserRolesCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRolesUserRolesCreatedServiceServer is the server API for UserRolesUserRolesCreatedService service.
// All implementations should embed UnimplementedUserRolesUserRolesCreatedServiceServer
// for forward compatibility.
//
// Publishes a UserRoleCreated to the User Roles channel. (oneOf variant) (userRoles UserRolesCreated)
type UserRolesUserRolesCreatedServiceServer interface {
	OnMessage(context.Context, *UserRoleCreated) (*emptypb.Empty, error)
}

// UnimplementedUserRolesUserRolesCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserRolesUserRolesCreatedServiceServer struct{}

func (UnimplementedUserRolesUserRolesCreatedServiceServer) OnMessage(context.Context, *UserRoleCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserRolesUserRolesCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserRolesUserRolesCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRolesUserRolesCreatedServiceServer will
// result in compilation errors.
type UnsafeUserRolesUserRolesCreatedServiceServer interface {
	mustEmbedUnimplementedUserRolesUserRolesCreatedServiceServer()
}

func RegisterUserRolesUserRolesCreatedServiceServer(s grpc.ServiceRegistrar, srv UserRolesUserRolesCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserRolesUserRolesCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserRolesUserRolesCreatedService_ServiceDesc, srv)
}

func _UserRolesUserRolesCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRolesUserRolesCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRolesUserRolesCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRolesUserRolesCreatedServiceServer).OnMessage(ctx, req.(*UserRoleCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRolesUserRolesCreatedService_ServiceDesc is the grpc.ServiceDesc for UserRolesUserRolesCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRolesUserRolesCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserRolesUserRolesCreatedService",
	HandlerType: (*UserRolesUserRolesCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserRolesUserRolesCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserRolesUserRolesDeletedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserRolesUserRolesDeletedService/OnMessage"
)

// UserRolesUserRolesDeletedServiceClient is the client API for UserRolesUserRolesDeletedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UserRoleDeleted to the User Roles channel. (oneOf variant) (userRoles UserRolesDeleted)
type UserRolesUserRolesDeletedServiceClient interface {
	OnMessage(ctx context.Context, in *UserRoleDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userRolesUserRolesDeletedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserRolesUserRolesDeletedServiceClient(cc grpc.ClientConnInterface) UserRolesUserRolesDeletedServiceClient {
	return &userRolesUserRolesDeletedServiceClient{cc}
}

func (c *userRolesUserRolesDeletedServiceClient) OnMessage(ctx context.Context, in *UserRoleDeleted, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserRolesUserRolesDeletedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserRolesUserRolesDeletedServiceServer is the server API for UserRolesUserRolesDeletedService service.
// All implementations should embed UnimplementedUserRolesUserRolesDeletedServiceServer
// for forward compatibility.
//
// Publishes a UserRoleDeleted to the User Roles channel. (oneOf variant) (userRoles UserRolesDeleted)
type UserRolesUserRolesDeletedServiceServer interface {
	OnMessage(context.Context, *UserRoleDeleted) (*emptypb.Empty, error)
}

// UnimplementedUserRolesUserRolesDeletedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserRolesUserRolesDeletedServiceServer struct{}

func (UnimplementedUserRolesUserRolesDeletedServiceServer) OnMessage(context.Context, *UserRoleDeleted) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserRolesUserRolesDeletedServiceServer) testEmbeddedByValue() {}

// UnsafeUserRolesUserRolesDeletedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserRolesUserRolesDeletedServiceServer will
// result in compilation errors.
type UnsafeUserRolesUserRolesDeletedServiceServer interface {
	mustEmbedUnimplementedUserRolesUserRolesDeletedServiceServer()
}

func RegisterUserRolesUserRolesDeletedServiceServer(s grpc.ServiceRegistrar, srv UserRolesUserRolesDeletedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserRolesUserRolesDeletedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserRolesUserRolesDeletedService_ServiceDesc, srv)
}

func _UserRolesUserRolesDeletedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleDeleted)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserRolesUserRolesDeletedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserRolesUserRolesDeletedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserRolesUserRolesDeletedServiceServer).OnMessage(ctx, req.(*UserRoleDeleted))
	}
	return interceptor(ctx, in, info, handler)
}

// UserRolesUserRolesDeletedService_ServiceDesc is the grpc.ServiceDesc for UserRolesUserRolesDeletedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserRolesUserRolesDeletedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserRolesUserRolesDeletedService",
	HandlerType: (*UserRolesUserRolesDeletedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserRolesUserRolesDeletedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	CountryAgeRestrictionCountryAgeRestrictionCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.CountryAgeRestrictionCountryAgeRestrictionCreatedService/OnMessage"
)

// CountryAgeRestrictionCountryAgeRestrictionCreatedServiceClient is the client API for CountryAgeRestrictionCountryAgeRestrictionCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a CountryAgeRestrictionCreated to the Country Age Restriction channel. (oneOf variant) (countryAgeRestriction CountryAgeRestrictionCreated)
type CountryAgeRestrictionCountryAgeRestrictionCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *CountryAgeRestrictionCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type countryAgeRestrictionCountryAgeRestrictionCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCountryAgeRestrictionCountryAgeRestrictionCreatedServiceClient(cc grpc.ClientConnInterface) CountryAgeRestrictionCountryAgeRestrictionCreatedServiceClient {
	return &countryAgeRestrictionCountryAgeRestrictionCreatedServiceClient{cc}
}

func (c *countryAgeRestrictionCountryAgeRestrictionCreatedServiceClient) OnMessage(ctx context.Context, in *CountryAgeRestrictionCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CountryAgeRestrictionCountryAgeRestrictionCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer is the server API for CountryAgeRestrictionCountryAgeRestrictionCreatedService service.
// All implementations should embed UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer
// for forward compatibility.
//
// Publishes a CountryAgeRestrictionCreated to the Country Age Restriction channel. (oneOf variant) (countryAgeRestriction CountryAgeRestrictionCreated)
type CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer interface {
	OnMessage(context.Context, *CountryAgeRestrictionCreated) (*emptypb.Empty, error)
}

// UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer struct{}

func (UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer) OnMessage(context.Context, *CountryAgeRestrictionCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer) testEmbeddedByValue() {
}

// UnsafeCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer will
// result in compilation errors.
type UnsafeCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer interface {
	mustEmbedUnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer()
}

func RegisterCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer(s grpc.ServiceRegistrar, srv CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedCountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CountryAgeRestrictionCountryAgeRestrictionCreatedService_ServiceDesc, srv)
}

func _CountryAgeRestrictionCountryAgeRestrictionCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountryAgeRestrictionCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryAgeRestrictionCountryAgeRestrictionCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer).OnMessage(ctx, req.(*CountryAgeRestrictionCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// CountryAgeRestrictionCountryAgeRestrictionCreatedService_ServiceDesc is the grpc.ServiceDesc for CountryAgeRestrictionCountryAgeRestrictionCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CountryAgeRestrictionCountryAgeRestrictionCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.CountryAgeRestrictionCountryAgeRestrictionCreatedService",
	HandlerType: (*CountryAgeRestrictionCountryAgeRestrictionCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _CountryAgeRestrictionCountryAgeRestrictionCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	CountryAgeRestrictionCountryAgeRestrictionUpdatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.CountryAgeRestrictionCountryAgeRestrictionUpdatedService/OnMessage"
)

// CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient is the client API for CountryAgeRestrictionCountryAgeRestrictionUpdatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a CountryAgeRestrictionUpdated to the Country Age Restriction channel. (oneOf variant) (countryAgeRestriction CountryAgeRestrictionUpdated)
type CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient interface {
	OnMessage(ctx context.Context, in *CountryAgeRestrictionUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type countryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient(cc grpc.ClientConnInterface) CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient {
	return &countryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient{cc}
}

func (c *countryAgeRestrictionCountryAgeRestrictionUpdatedServiceClient) OnMessage(ctx context.Context, in *CountryAgeRestrictionUpdated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, CountryAgeRestrictionCountryAgeRestrictionUpdatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer is the server API for CountryAgeRestrictionCountryAgeRestrictionUpdatedService service.
// All implementations should embed UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer
// for forward compatibility.
//
// Publishes a CountryAgeRestrictionUpdated to the Country Age Restriction channel. (oneOf variant) (countryAgeRestriction CountryAgeRestrictionUpdated)
type CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer interface {
	OnMessage(context.Context, *CountryAgeRestrictionUpdated) (*emptypb.Empty, error)
}

// UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer struct{}

func (UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer) OnMessage(context.Context, *CountryAgeRestrictionUpdated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer) testEmbeddedByValue() {
}

// UnsafeCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer will
// result in compilation errors.
type UnsafeCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer interface {
	mustEmbedUnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer()
}

func RegisterCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer(s grpc.ServiceRegistrar, srv CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedCountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CountryAgeRestrictionCountryAgeRestrictionUpdatedService_ServiceDesc, srv)
}

func _CountryAgeRestrictionCountryAgeRestrictionUpdatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountryAgeRestrictionUpdated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CountryAgeRestrictionCountryAgeRestrictionUpdatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer).OnMessage(ctx, req.(*CountryAgeRestrictionUpdated))
	}
	return interceptor(ctx, in, info, handler)
}

// CountryAgeRestrictionCountryAgeRestrictionUpdatedService_ServiceDesc is the grpc.ServiceDesc for CountryAgeRestrictionCountryAgeRestrictionUpdatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CountryAgeRestrictionCountryAgeRestrictionUpdatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.CountryAgeRestrictionCountryAgeRestrictionUpdatedService",
	HandlerType: (*CountryAgeRestrictionCountryAgeRestrictionUpdatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _CountryAgeRestrictionCountryAgeRestrictionUpdatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserTranslationsGameUserCreatedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserTranslationsGameUserCreatedService/OnMessage"
)

// UserTranslationsGameUserCreatedServiceClient is the client API for UserTranslationsGameUserCreatedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the User Translations channel. (userTranslations GameUserCreated)
type UserTranslationsGameUserCreatedServiceClient interface {
	OnMessage(ctx context.Context, in *GameUserCreated, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userTranslationsGameUserCreatedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserTranslationsGameUserCreatedServiceClient(cc grpc.ClientConnInterface) UserTranslationsGameUserCreatedServiceClient {
	return &userTranslationsGameUserCreatedServiceClient{cc}
}

func (c *userTranslationsGameUserCreatedServiceClient) OnMessage(ctx context.Context, in *GameUserCreated, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserTranslationsGameUserCreatedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserTranslationsGameUserCreatedServiceServer is the server API for UserTranslationsGameUserCreatedService service.
// All implementations should embed UnimplementedUserTranslationsGameUserCreatedServiceServer
// for forward compatibility.
//
// Publishes a message to the User Translations channel. (userTranslations GameUserCreated)
type UserTranslationsGameUserCreatedServiceServer interface {
	OnMessage(context.Context, *GameUserCreated) (*emptypb.Empty, error)
}

// UnimplementedUserTranslationsGameUserCreatedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserTranslationsGameUserCreatedServiceServer struct{}

func (UnimplementedUserTranslationsGameUserCreatedServiceServer) OnMessage(context.Context, *GameUserCreated) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserTranslationsGameUserCreatedServiceServer) testEmbeddedByValue() {}

// UnsafeUserTranslationsGameUserCreatedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserTranslationsGameUserCreatedServiceServer will
// result in compilation errors.
type UnsafeUserTranslationsGameUserCreatedServiceServer interface {
	mustEmbedUnimplementedUserTranslationsGameUserCreatedServiceServer()
}

func RegisterUserTranslationsGameUserCreatedServiceServer(s grpc.ServiceRegistrar, srv UserTranslationsGameUserCreatedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserTranslationsGameUserCreatedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserTranslationsGameUserCreatedService_ServiceDesc, srv)
}

func _UserTranslationsGameUserCreatedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GameUserCreated)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserTranslationsGameUserCreatedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserTranslationsGameUserCreatedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserTranslationsGameUserCreatedServiceServer).OnMessage(ctx, req.(*GameUserCreated))
	}
	return interceptor(ctx, in, info, handler)
}

// UserTranslationsGameUserCreatedService_ServiceDesc is the grpc.ServiceDesc for UserTranslationsGameUserCreatedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserTranslationsGameUserCreatedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserTranslationsGameUserCreatedService",
	HandlerType: (*UserTranslationsGameUserCreatedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserTranslationsGameUserCreatedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanChatAllBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanChatAllBannedService/OnMessage"
)

// UserFeatureBanChatAllBannedServiceClient is the client API for UserFeatureBanChatAllBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a ChatAllBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan ChatAllBanned)
type UserFeatureBanChatAllBannedServiceClient interface {
	OnMessage(ctx context.Context, in *ChatAllBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanChatAllBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanChatAllBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanChatAllBannedServiceClient {
	return &userFeatureBanChatAllBannedServiceClient{cc}
}

func (c *userFeatureBanChatAllBannedServiceClient) OnMessage(ctx context.Context, in *ChatAllBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanChatAllBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanChatAllBannedServiceServer is the server API for UserFeatureBanChatAllBannedService service.
// All implementations should embed UnimplementedUserFeatureBanChatAllBannedServiceServer
// for forward compatibility.
//
// Publishes a ChatAllBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan ChatAllBanned)
type UserFeatureBanChatAllBannedServiceServer interface {
	OnMessage(context.Context, *ChatAllBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanChatAllBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanChatAllBannedServiceServer struct{}

func (UnimplementedUserFeatureBanChatAllBannedServiceServer) OnMessage(context.Context, *ChatAllBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanChatAllBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanChatAllBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanChatAllBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanChatAllBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanChatAllBannedServiceServer()
}

func RegisterUserFeatureBanChatAllBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanChatAllBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanChatAllBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanChatAllBannedService_ServiceDesc, srv)
}

func _UserFeatureBanChatAllBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatAllBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanChatAllBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanChatAllBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanChatAllBannedServiceServer).OnMessage(ctx, req.(*ChatAllBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanChatAllBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanChatAllBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanChatAllBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanChatAllBannedService",
	HandlerType: (*UserFeatureBanChatAllBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanChatAllBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanChatSendBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanChatSendBannedService/OnMessage"
)

// UserFeatureBanChatSendBannedServiceClient is the client API for UserFeatureBanChatSendBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a ChatSendBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan ChatSendBanned)
type UserFeatureBanChatSendBannedServiceClient interface {
	OnMessage(ctx context.Context, in *ChatSendBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanChatSendBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanChatSendBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanChatSendBannedServiceClient {
	return &userFeatureBanChatSendBannedServiceClient{cc}
}

func (c *userFeatureBanChatSendBannedServiceClient) OnMessage(ctx context.Context, in *ChatSendBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanChatSendBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanChatSendBannedServiceServer is the server API for UserFeatureBanChatSendBannedService service.
// All implementations should embed UnimplementedUserFeatureBanChatSendBannedServiceServer
// for forward compatibility.
//
// Publishes a ChatSendBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan ChatSendBanned)
type UserFeatureBanChatSendBannedServiceServer interface {
	OnMessage(context.Context, *ChatSendBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanChatSendBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanChatSendBannedServiceServer struct{}

func (UnimplementedUserFeatureBanChatSendBannedServiceServer) OnMessage(context.Context, *ChatSendBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanChatSendBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanChatSendBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanChatSendBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanChatSendBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanChatSendBannedServiceServer()
}

func RegisterUserFeatureBanChatSendBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanChatSendBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanChatSendBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanChatSendBannedService_ServiceDesc, srv)
}

func _UserFeatureBanChatSendBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatSendBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanChatSendBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanChatSendBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanChatSendBannedServiceServer).OnMessage(ctx, req.(*ChatSendBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanChatSendBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanChatSendBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanChatSendBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanChatSendBannedService",
	HandlerType: (*UserFeatureBanChatSendBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanChatSendBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanLeaderboardBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanLeaderboardBannedService/OnMessage"
)

// UserFeatureBanLeaderboardBannedServiceClient is the client API for UserFeatureBanLeaderboardBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a LeaderboardBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan LeaderboardBanned)
type UserFeatureBanLeaderboardBannedServiceClient interface {
	OnMessage(ctx context.Context, in *LeaderboardBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanLeaderboardBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanLeaderboardBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanLeaderboardBannedServiceClient {
	return &userFeatureBanLeaderboardBannedServiceClient{cc}
}

func (c *userFeatureBanLeaderboardBannedServiceClient) OnMessage(ctx context.Context, in *LeaderboardBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanLeaderboardBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanLeaderboardBannedServiceServer is the server API for UserFeatureBanLeaderboardBannedService service.
// All implementations should embed UnimplementedUserFeatureBanLeaderboardBannedServiceServer
// for forward compatibility.
//
// Publishes a LeaderboardBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan LeaderboardBanned)
type UserFeatureBanLeaderboardBannedServiceServer interface {
	OnMessage(context.Context, *LeaderboardBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanLeaderboardBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanLeaderboardBannedServiceServer struct{}

func (UnimplementedUserFeatureBanLeaderboardBannedServiceServer) OnMessage(context.Context, *LeaderboardBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanLeaderboardBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanLeaderboardBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanLeaderboardBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanLeaderboardBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanLeaderboardBannedServiceServer()
}

func RegisterUserFeatureBanLeaderboardBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanLeaderboardBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanLeaderboardBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanLeaderboardBannedService_ServiceDesc, srv)
}

func _UserFeatureBanLeaderboardBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaderboardBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanLeaderboardBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanLeaderboardBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanLeaderboardBannedServiceServer).OnMessage(ctx, req.(*LeaderboardBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanLeaderboardBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanLeaderboardBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanLeaderboardBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanLeaderboardBannedService",
	HandlerType: (*UserFeatureBanLeaderboardBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanLeaderboardBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanStatisticsBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanStatisticsBannedService/OnMessage"
)

// UserFeatureBanStatisticsBannedServiceClient is the client API for UserFeatureBanStatisticsBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a StatisticsBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan StatisticsBanned)
type UserFeatureBanStatisticsBannedServiceClient interface {
	OnMessage(ctx context.Context, in *StatisticsBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanStatisticsBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanStatisticsBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanStatisticsBannedServiceClient {
	return &userFeatureBanStatisticsBannedServiceClient{cc}
}

func (c *userFeatureBanStatisticsBannedServiceClient) OnMessage(ctx context.Context, in *StatisticsBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanStatisticsBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanStatisticsBannedServiceServer is the server API for UserFeatureBanStatisticsBannedService service.
// All implementations should embed UnimplementedUserFeatureBanStatisticsBannedServiceServer
// for forward compatibility.
//
// Publishes a StatisticsBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan StatisticsBanned)
type UserFeatureBanStatisticsBannedServiceServer interface {
	OnMessage(context.Context, *StatisticsBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanStatisticsBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanStatisticsBannedServiceServer struct{}

func (UnimplementedUserFeatureBanStatisticsBannedServiceServer) OnMessage(context.Context, *StatisticsBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanStatisticsBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanStatisticsBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanStatisticsBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanStatisticsBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanStatisticsBannedServiceServer()
}

func RegisterUserFeatureBanStatisticsBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanStatisticsBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanStatisticsBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanStatisticsBannedService_ServiceDesc, srv)
}

func _UserFeatureBanStatisticsBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatisticsBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanStatisticsBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanStatisticsBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanStatisticsBannedServiceServer).OnMessage(ctx, req.(*StatisticsBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanStatisticsBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanStatisticsBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanStatisticsBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanStatisticsBannedService",
	HandlerType: (*UserFeatureBanStatisticsBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanStatisticsBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanOrderAndPaymentBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanOrderAndPaymentBannedService/OnMessage"
)

// UserFeatureBanOrderAndPaymentBannedServiceClient is the client API for UserFeatureBanOrderAndPaymentBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a OrderAndPaymentBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan OrderAndPaymentBanned)
type UserFeatureBanOrderAndPaymentBannedServiceClient interface {
	OnMessage(ctx context.Context, in *OrderAndPaymentBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanOrderAndPaymentBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanOrderAndPaymentBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanOrderAndPaymentBannedServiceClient {
	return &userFeatureBanOrderAndPaymentBannedServiceClient{cc}
}

func (c *userFeatureBanOrderAndPaymentBannedServiceClient) OnMessage(ctx context.Context, in *OrderAndPaymentBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanOrderAndPaymentBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanOrderAndPaymentBannedServiceServer is the server API for UserFeatureBanOrderAndPaymentBannedService service.
// All implementations should embed UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer
// for forward compatibility.
//
// Publishes a OrderAndPaymentBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan OrderAndPaymentBanned)
type UserFeatureBanOrderAndPaymentBannedServiceServer interface {
	OnMessage(context.Context, *OrderAndPaymentBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer struct{}

func (UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer) OnMessage(context.Context, *OrderAndPaymentBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanOrderAndPaymentBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanOrderAndPaymentBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanOrderAndPaymentBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer()
}

func RegisterUserFeatureBanOrderAndPaymentBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanOrderAndPaymentBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanOrderAndPaymentBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanOrderAndPaymentBannedService_ServiceDesc, srv)
}

func _UserFeatureBanOrderAndPaymentBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderAndPaymentBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanOrderAndPaymentBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanOrderAndPaymentBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanOrderAndPaymentBannedServiceServer).OnMessage(ctx, req.(*OrderAndPaymentBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanOrderAndPaymentBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanOrderAndPaymentBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanOrderAndPaymentBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanOrderAndPaymentBannedService",
	HandlerType: (*UserFeatureBanOrderAndPaymentBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanOrderAndPaymentBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanMatchmakingBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanMatchmakingBannedService/OnMessage"
)

// UserFeatureBanMatchmakingBannedServiceClient is the client API for UserFeatureBanMatchmakingBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a MatchmakingBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan MatchmakingBanned)
type UserFeatureBanMatchmakingBannedServiceClient interface {
	OnMessage(ctx context.Context, in *MatchmakingBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanMatchmakingBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanMatchmakingBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanMatchmakingBannedServiceClient {
	return &userFeatureBanMatchmakingBannedServiceClient{cc}
}

func (c *userFeatureBanMatchmakingBannedServiceClient) OnMessage(ctx context.Context, in *MatchmakingBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanMatchmakingBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanMatchmakingBannedServiceServer is the server API for UserFeatureBanMatchmakingBannedService service.
// All implementations should embed UnimplementedUserFeatureBanMatchmakingBannedServiceServer
// for forward compatibility.
//
// Publishes a MatchmakingBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan MatchmakingBanned)
type UserFeatureBanMatchmakingBannedServiceServer interface {
	OnMessage(context.Context, *MatchmakingBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanMatchmakingBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanMatchmakingBannedServiceServer struct{}

func (UnimplementedUserFeatureBanMatchmakingBannedServiceServer) OnMessage(context.Context, *MatchmakingBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanMatchmakingBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanMatchmakingBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanMatchmakingBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanMatchmakingBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanMatchmakingBannedServiceServer()
}

func RegisterUserFeatureBanMatchmakingBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanMatchmakingBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanMatchmakingBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanMatchmakingBannedService_ServiceDesc, srv)
}

func _UserFeatureBanMatchmakingBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchmakingBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanMatchmakingBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanMatchmakingBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanMatchmakingBannedServiceServer).OnMessage(ctx, req.(*MatchmakingBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanMatchmakingBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanMatchmakingBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanMatchmakingBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanMatchmakingBannedService",
	HandlerType: (*UserFeatureBanMatchmakingBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanMatchmakingBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	UserFeatureBanUgcCreateUpdateBannedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.UserFeatureBanUgcCreateUpdateBannedService/OnMessage"
)

// UserFeatureBanUgcCreateUpdateBannedServiceClient is the client API for UserFeatureBanUgcCreateUpdateBannedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a UgcCreateUpdateBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan UgcCreateUpdateBanned)
type UserFeatureBanUgcCreateUpdateBannedServiceClient interface {
	OnMessage(ctx context.Context, in *UgcCreateUpdateBanned, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type userFeatureBanUgcCreateUpdateBannedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserFeatureBanUgcCreateUpdateBannedServiceClient(cc grpc.ClientConnInterface) UserFeatureBanUgcCreateUpdateBannedServiceClient {
	return &userFeatureBanUgcCreateUpdateBannedServiceClient{cc}
}

func (c *userFeatureBanUgcCreateUpdateBannedServiceClient) OnMessage(ctx context.Context, in *UgcCreateUpdateBanned, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, UserFeatureBanUgcCreateUpdateBannedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserFeatureBanUgcCreateUpdateBannedServiceServer is the server API for UserFeatureBanUgcCreateUpdateBannedService service.
// All implementations should embed UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer
// for forward compatibility.
//
// Publishes a UgcCreateUpdateBanned to the User Feature Ban channel. (oneOf variant) (userFeatureBan UgcCreateUpdateBanned)
type UserFeatureBanUgcCreateUpdateBannedServiceServer interface {
	OnMessage(context.Context, *UgcCreateUpdateBanned) (*emptypb.Empty, error)
}

// UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer struct{}

func (UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer) OnMessage(context.Context, *UgcCreateUpdateBanned) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer) testEmbeddedByValue() {}

// UnsafeUserFeatureBanUgcCreateUpdateBannedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserFeatureBanUgcCreateUpdateBannedServiceServer will
// result in compilation errors.
type UnsafeUserFeatureBanUgcCreateUpdateBannedServiceServer interface {
	mustEmbedUnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer()
}

func RegisterUserFeatureBanUgcCreateUpdateBannedServiceServer(s grpc.ServiceRegistrar, srv UserFeatureBanUgcCreateUpdateBannedServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserFeatureBanUgcCreateUpdateBannedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserFeatureBanUgcCreateUpdateBannedService_ServiceDesc, srv)
}

func _UserFeatureBanUgcCreateUpdateBannedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UgcCreateUpdateBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserFeatureBanUgcCreateUpdateBannedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserFeatureBanUgcCreateUpdateBannedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserFeatureBanUgcCreateUpdateBannedServiceServer).OnMessage(ctx, req.(*UgcCreateUpdateBanned))
	}
	return interceptor(ctx, in, info, handler)
}

// UserFeatureBanUgcCreateUpdateBannedService_ServiceDesc is the grpc.ServiceDesc for UserFeatureBanUgcCreateUpdateBannedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserFeatureBanUgcCreateUpdateBannedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.UserFeatureBanUgcCreateUpdateBannedService",
	HandlerType: (*UserFeatureBanUgcCreateUpdateBannedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _UserFeatureBanUgcCreateUpdateBannedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	LobbyUserDisconnectRequestedService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.LobbyUserDisconnectRequestedService/OnMessage"
)

// LobbyUserDisconnectRequestedServiceClient is the client API for LobbyUserDisconnectRequestedService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the Lobby channel. (lobby UserDisconnectRequested)
type LobbyUserDisconnectRequestedServiceClient interface {
	OnMessage(ctx context.Context, in *UserDisconnectRequested, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type lobbyUserDisconnectRequestedServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLobbyUserDisconnectRequestedServiceClient(cc grpc.ClientConnInterface) LobbyUserDisconnectRequestedServiceClient {
	return &lobbyUserDisconnectRequestedServiceClient{cc}
}

func (c *lobbyUserDisconnectRequestedServiceClient) OnMessage(ctx context.Context, in *UserDisconnectRequested, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LobbyUserDisconnectRequestedService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LobbyUserDisconnectRequestedServiceServer is the server API for LobbyUserDisconnectRequestedService service.
// All implementations should embed UnimplementedLobbyUserDisconnectRequestedServiceServer
// for forward compatibility.
//
// Publishes a message to the Lobby channel. (lobby UserDisconnectRequested)
type LobbyUserDisconnectRequestedServiceServer interface {
	OnMessage(context.Context, *UserDisconnectRequested) (*emptypb.Empty, error)
}

// UnimplementedLobbyUserDisconnectRequestedServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLobbyUserDisconnectRequestedServiceServer struct{}

func (UnimplementedLobbyUserDisconnectRequestedServiceServer) OnMessage(context.Context, *UserDisconnectRequested) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedLobbyUserDisconnectRequestedServiceServer) testEmbeddedByValue() {}

// UnsafeLobbyUserDisconnectRequestedServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LobbyUserDisconnectRequestedServiceServer will
// result in compilation errors.
type UnsafeLobbyUserDisconnectRequestedServiceServer interface {
	mustEmbedUnimplementedLobbyUserDisconnectRequestedServiceServer()
}

func RegisterLobbyUserDisconnectRequestedServiceServer(s grpc.ServiceRegistrar, srv LobbyUserDisconnectRequestedServiceServer) {
	// If the following call pancis, it indicates UnimplementedLobbyUserDisconnectRequestedServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LobbyUserDisconnectRequestedService_ServiceDesc, srv)
}

func _LobbyUserDisconnectRequestedService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDisconnectRequested)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyUserDisconnectRequestedServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyUserDisconnectRequestedService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyUserDisconnectRequestedServiceServer).OnMessage(ctx, req.(*UserDisconnectRequested))
	}
	return interceptor(ctx, in, info, handler)
}

// LobbyUserDisconnectRequestedService_ServiceDesc is the grpc.ServiceDesc for LobbyUserDisconnectRequestedService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LobbyUserDisconnectRequestedService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.LobbyUserDisconnectRequestedService",
	HandlerType: (*LobbyUserDisconnectRequestedServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _LobbyUserDisconnectRequestedService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}

const (
	DeletionAccountGdprGdprRequestDataDeletionResponseService_OnMessage_FullMethodName = "/accelbyte.iam.account.v1.DeletionAccountGdprGdprRequestDataDeletionResponseService/OnMessage"
)

// DeletionAccountGdprGdprRequestDataDeletionResponseServiceClient is the client API for DeletionAccountGdprGdprRequestDataDeletionResponseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Publishes a message to the Deletion Account Gdpr channel. (deletion_account_gdpr GdprRequestDataDeletionResponse)
type DeletionAccountGdprGdprRequestDataDeletionResponseServiceClient interface {
	OnMessage(ctx context.Context, in *GdprRequestDataDeletionResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type deletionAccountGdprGdprRequestDataDeletionResponseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDeletionAccountGdprGdprRequestDataDeletionResponseServiceClient(cc grpc.ClientConnInterface) DeletionAccountGdprGdprRequestDataDeletionResponseServiceClient {
	return &deletionAccountGdprGdprRequestDataDeletionResponseServiceClient{cc}
}

func (c *deletionAccountGdprGdprRequestDataDeletionResponseServiceClient) OnMessage(ctx context.Context, in *GdprRequestDataDeletionResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DeletionAccountGdprGdprRequestDataDeletionResponseService_OnMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer is the server API for DeletionAccountGdprGdprRequestDataDeletionResponseService service.
// All implementations should embed UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer
// for forward compatibility.
//
// Publishes a message to the Deletion Account Gdpr channel. (deletion_account_gdpr GdprRequestDataDeletionResponse)
type DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer interface {
	OnMessage(context.Context, *GdprRequestDataDeletionResponse) (*emptypb.Empty, error)
}

// UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer struct{}

func (UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer) OnMessage(context.Context, *GdprRequestDataDeletionResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMessage not implemented")
}
func (UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer) testEmbeddedByValue() {
}

// UnsafeDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer will
// result in compilation errors.
type UnsafeDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer interface {
	mustEmbedUnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer()
}

func RegisterDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer(s grpc.ServiceRegistrar, srv DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer) {
	// If the following call pancis, it indicates UnimplementedDeletionAccountGdprGdprRequestDataDeletionResponseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DeletionAccountGdprGdprRequestDataDeletionResponseService_ServiceDesc, srv)
}

func _DeletionAccountGdprGdprRequestDataDeletionResponseService_OnMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GdprRequestDataDeletionResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer).OnMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DeletionAccountGdprGdprRequestDataDeletionResponseService_OnMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer).OnMessage(ctx, req.(*GdprRequestDataDeletionResponse))
	}
	return interceptor(ctx, in, info, handler)
}

// DeletionAccountGdprGdprRequestDataDeletionResponseService_ServiceDesc is the grpc.ServiceDesc for DeletionAccountGdprGdprRequestDataDeletionResponseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DeletionAccountGdprGdprRequestDataDeletionResponseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "accelbyte.iam.account.v1.DeletionAccountGdprGdprRequestDataDeletionResponseService",
	HandlerType: (*DeletionAccountGdprGdprRequestDataDeletionResponseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMessage",
			Handler:    _DeletionAccountGdprGdprRequestDataDeletionResponseService_OnMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "accelbyte-asyncapi/iam/account/v1/account.proto",
}
